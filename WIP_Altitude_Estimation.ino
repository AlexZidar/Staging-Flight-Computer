/* CURRENTLY UNTESTED
 * 
 *Flawed theory behind code, do not use. Requires much more complex use of a 9-Axis IMU for heading estimation from which purely vertical acceleration can be found.
 *
 * Rocket Altitude Logger with Kalman Filter
 * For Teensy 4.1 with SparkFun H3LIS331DL and Adafruit BMP390
 * 
 * Code primarily generated by Claud 3.7 Sonnet with review by me
 *
 * This program combines accelerometer and barometer readings using
 * a 2D Kalman filter to estimate accurate rocket altitude and
 * logs the data to the SD card.
 */

#include <Wire.h>
#include <SD.h>
#include <SPI.h>
#include <Adafruit_BMP3XX.h>
#include <SparkFun_H3LIS331DL_Arduino_Library.h>

// Pin definitions
#define SD_CS_PIN BUILTIN_SDCARD

// Sensor objects
Adafruit_BMP3XX bmp;
H3LIS331DL accelerometer;

// File object for logging
File dataFile;

// Sea level pressure for altitude calculations
#define SEALEVELPRESSURE_HPA (1013.25)

// Kalman filter variables
float x_est[2] = {0, 0};   // State vector [position, velocity]
float P[2][2] = {{1, 0},   // Error covariance matrix
                 {0, 1}};
float Q[2][2] = {{0.01, 0},   // Process noise covariance (can be tuned)
                 {0, 0.01}};
float R_accel = 10.0;      // Accelerometer measurement noise (can be tuned)
float R_baro = 2.0;        // Barometer measurement noise (can be tuned)

// Timing variables
unsigned long lastUpdateTime = 0;
const int UPDATE_RATE_MS = 10;  // 100 Hz update rate

// Function prototypes
bool initSensors();
bool initSDCard();
void updateKalmanWithAccel(float accel, float dt);
void updateKalmanWithBaro(float altitude);
void logData(float rawAccel, float rawAltitude, float filteredAltitude, float velocity);

void setup() {
  Serial.begin(115200);
  Wire.begin();
  
  // Wait for serial monitor to open
  while (!Serial && millis() < 3000) {
    delay(100);
  }
  
  Serial.println("Rocket Altitude Logger");
  
  // Initialize sensors
  if (!initSensors()) {
    Serial.println("Failed to initialize one or more sensors!");
    while(1) { delay(100); }  // Halt if sensor init fails
  }
  
  // Initialize SD card
  if (!initSDCard()) {
    Serial.println("SD card initialization failed!");
    while(1) { delay(100); }  // Halt if SD init fails
  }
  
  // Create data file with header
  dataFile = SD.open("rocket.csv", FILE_WRITE);
  if (dataFile) {
    dataFile.println("Time(ms),RawAccel(m/s^2),RawAltitude(m),FilteredAltitude(m),Velocity(m/s)");
    dataFile.flush();
    Serial.println("Data file created");
  } else {
    Serial.println("Could not create data file!");
    while(1) { delay(100); }  // Halt if file creation fails
  }
  
  lastUpdateTime = millis();
  Serial.println("System ready!");
}

void loop() {
  unsigned long currentTime = millis();
  float dt = (currentTime - lastUpdateTime) / 1000.0;  // Convert to seconds
  
  if (dt >= UPDATE_RATE_MS / 1000.0) {
    // Read accelerometer (convert to m/s^2)
    accelerometer.readAccelData();
    float rawAccelZ = accelerometer.accelZ * 9.81;  // Convert from g to m/s^2
    float accel = rawAccelZ - 9.81;  // Remove gravity to get pure acceleration
    
    // Read barometer
    float temperature = 0;
    float pressure = 0;
    float rawAltitude = 0;
    
    if (bmp.performReading()) {
      temperature = bmp.temperature;
      pressure = bmp.pressure / 100.0;  // Convert to hPa
      rawAltitude = bmp.readAltitude(SEALEVELPRESSURE_HPA);
    }
    
    // Update Kalman filter with accelerometer data
    updateKalmanWithAccel(accel, dt);
    
    // Update Kalman filter with barometer data
    updateKalmanWithBaro(rawAltitude);
    
    // Log data
    logData(accel, rawAltitude, x_est[0], x_est[1]);
    
    // Update timing
    lastUpdateTime = currentTime;
  }
}

bool initSensors() {
  bool success = true;
  
  // Initialize accelerometer
  if (!accelerometer.begin()) {
    Serial.println("H3LIS331DL not detected!");
    success = false;
  } else {
    // Configure accelerometer settings
    accelerometer.setRange(H3LIS331DL_RANGE_100G);  // Set range to 100g
    accelerometer.setDataRate(H3LIS331DL_DATARATE_1000HZ);  // Set data rate to 1000Hz
    Serial.println("H3LIS331DL initialized");
  }
  
  // Initialize barometer
  if (!bmp.begin_I2C()) {
    Serial.println("BMP390 not detected!");
    success = false;
  } else {
    // Configure barometer settings
    bmp.setTemperatureOversampling(BMP3_OVERSAMPLING_8X);
    bmp.setPressureOversampling(BMP3_OVERSAMPLING_4X);
    bmp.setIIRFilterCoeff(BMP3_IIR_FILTER_COEFF_3);
    bmp.setOutputDataRate(BMP3_ODR_50_HZ);
    Serial.println("BMP390 initialized");
  }
  
  return success;
}

bool initSDCard() {
  if (!SD.begin(SD_CS_PIN)) {
    return false;
  }
  return true;
}

void updateKalmanWithAccel(float accel, float dt) {
  // State transition matrix calculation (for position and velocity)
  // x_k = x_k-1 + v_k-1 * dt + 0.5 * a * dt^2
  // v_k = v_k-1 + a * dt
  
  // Prediction step
  // Update state estimate
  float x_pred[2];
  x_pred[0] = x_est[0] + x_est[1] * dt + 0.5 * accel * dt * dt;
  x_pred[1] = x_est[1] + accel * dt;
  
  // Update error covariance matrix
  float F[2][2] = {{1, dt}, {0, 1}};  // State transition matrix
  float F_t[2][2] = {{1, 0}, {dt, 1}};  // Transpose of F
  
  // Calculate P = F*P*F' + Q
  float temp[2][2];
  // temp = F * P
  temp[0][0] = F[0][0] * P[0][0] + F[0][1] * P[1][0];
  temp[0][1] = F[0][0] * P[0][1] + F[0][1] * P[1][1];
  temp[1][0] = F[1][0] * P[0][0] + F[1][1] * P[1][0];
  temp[1][1] = F[1][0] * P[0][1] + F[1][1] * P[1][1];
  
  // P = temp * F' + Q
  P[0][0] = temp[0][0] * F_t[0][0] + temp[0][1] * F_t[0][1] + Q[0][0];
  P[0][1] = temp[0][0] * F_t[1][0] + temp[0][1] * F_t[1][1] + Q[0][1];
  P[1][0] = temp[1][0] * F_t[0][0] + temp[1][1] * F_t[0][1] + Q[1][0];
  P[1][1] = temp[1][0] * F_t[1][0] + temp[1][1] * F_t[1][1] + Q[1][1];
  
  // Copy predicted values to estimated state
  x_est[0] = x_pred[0];
  x_est[1] = x_pred[1];
}

void updateKalmanWithBaro(float altitude) {
  // Measurement update step for barometer (position only)
  
  // Skip update if barometer reading is invalid
  if (isnan(altitude) || altitude < -100 || altitude > 10000) {
    return;
  }
  
  // Calculate Kalman gain
  float H[2] = {1, 0}; // Measurement matrix for position
  float HP[2];
  HP[0] = H[0] * P[0][0] + H[1] * P[1][0];
  HP[1] = H[0] * P[0][1] + H[1] * P[1][1];
  
  float S = HP[0] * H[0] + HP[1] * H[1] + R_baro;
  
  float K[2];
  K[0] = HP[0] / S;
  K[1] = HP[1] / S;
  
  // Update state estimate
  float y = altitude - H[0] * x_est[0] - H[1] * x_est[1];
  x_est[0] += K[0] * y;
  x_est[1] += K[1] * y;
  
  // Update error covariance matrix
  float P_temp[2][2];
  P_temp[0][0] = P[0][0] - K[0] * HP[0];
  P_temp[0][1] = P[0][1] - K[0] * HP[1];
  P_temp[1][0] = P[1][0] - K[1] * HP[0];
  P_temp[1][1] = P[1][1] - K[1] * HP[1];
  
  P[0][0] = P_temp[0][0];
  P[0][1] = P_temp[0][1];
  P[1][0] = P_temp[1][0];
  P[1][1] = P_temp[1][1];
}

void logData(float rawAccel, float rawAltitude, float filteredAltitude, float velocity) {
  if (dataFile) {
    // Format data as CSV: time,rawAccel,rawAltitude,filteredAltitude,velocity
    dataFile.print(millis());
    dataFile.print(",");
    dataFile.print(rawAccel, 4);
    dataFile.print(",");
    dataFile.print(rawAltitude, 4);
    dataFile.print(",");
    dataFile.print(filteredAltitude, 4);
    dataFile.print(",");
    dataFile.println(velocity, 4);
    
    // Flush data periodically to ensure it's written
    if (millis() % 500 == 0) {
      dataFile.flush();
    }
    
    // Debug output
    if (millis() % 1000 == 0) {  // Print once per second
      Serial.print("Alt: ");
      Serial.print(filteredAltitude, 2);
      Serial.print("m, Vel: ");
      Serial.print(velocity, 2);
      Serial.println("m/s");
    }
  }
}
